###########################General information###################
#000 ——> z=3
#001 ——> z=2
#002 ——> z=1
#003 ——> z=0.5
#004 ——> z=0

###########################To import the particle data###################
import readgadget
import numpy as np
import MAS_library as MASL

# input files
snapshot = '/Users/finlaysime/Desktop/Senior Honour Project/snapdir_004/snap_004'
print(f"snapshot files imported")

#[1](CDM), [2](neutrinos) or [1,2](CDM+neutrinos)
while True:
 print(f"CDM - 1, neutrinos - 2, CDM & neutrinos - 1,2")
 no = str(input("Enter: "))

 if no == '1':
     ptype = [1]
     Title = 'CDM'
     break
 elif no == '2':
     ptype = [2]
     Title = 'neutrinos'
     break
 elif no == '1,2':
     ptype = [1,2]
     Title = 'CDM & neutrinos'
     break
 else:
     print('invalid input')

# read header
header   = readgadget.header(snapshot)
BoxSize  = header.boxsize/1e3  #Mpc/h
Nall     = header.nall         #Total number of particles
Masses   = header.massarr*1e10 #Masses of the particles in Msun/h
Omega_m  = header.omega_m      #value of Omega_m
Omega_l  = header.omega_l      #value of Omega_l
h        = header.hubble       #value of h
redshift = header.redshift     #redshift of the snapshot
Hubble   = 100.0*np.sqrt(Omega_m*(1.0+redshift)**3+Omega_l)#Value of H(z) in km/s/(Mpc/h)

# read positions, velocities and IDs of the particles
pos_dm = readgadget.read_block(snapshot, "POS ", ptype)/1e3 #positions in Mpc/h
vel_dm = readgadget.read_block(snapshot, "VEL ", ptype)     #peculiar velocities in km/s
ids_dm = readgadget.read_block(snapshot, "ID  ", ptype)-1
print("Positions & velocities acquired")

#############################To get the halo catalog######################################

f_catalog = '/Users/finlaysime/Desktop/Senior Honour Project/halos/1/out_4_pid.list' 

# read the halo catalog
data = np.loadtxt(f_catalog)
print("Halo data imported")

pid  = data[:,41]
idx = pid == -1  #ids of the halos
data_halo = data[idx]

#Units: Masses in Msun / h
#Units: Positions in Mpc / h (comoving)
#Units: Velocities in km / s (physical, peculiar)
#BoxSize=1000.0

halo_pos = data_halo[:,8:11]
halo_velocity = data_halo[:,11:14]
halo_mass = data_halo[:,2]
print("Halo positions, velocites, & masses acquired")

#############################Build density field######################################

grid = int(input("Grid size: ")) #the density field will have grid^3 voxels
# (tutorial gave 512, Yan-Chuan said 128 for neutrinos possibly)
MAS = 'CIC' #Mass-assignment scheme:'NGP', 'CIC', 'TSC', 'PCS'
verbose = True #whether to print information about progress

#Print some information
print('BoxSize: %.3f Mpc/h'%BoxSize)
print('Redshift: %.3f'%redshift)
print('%.3f < X < %.3f'%(np.min(pos_dm[:,0]), np.max(pos_dm[:,0])))
print('%.3f < Y < %.3f'%(np.min(pos_dm[:,1]), np.max(pos_dm[:,1])))
print('%.3f < Z < %.3f'%(np.min(pos_dm[:,2]), np.max(pos_dm[:,2])))

# create the 3D array to hold data in
delta = np.zeros((grid,grid,grid), dtype=np.float32)

# construct 3D density field

# assign mass to 3D array to create a density field
MASL.MA(pos_dm, delta, BoxSize, MAS, verbose=verbose)

# the sum of the values in all voxels should be equal to the number of particles
print('%.3f should be equal to\n%.3f'%(np.sum(delta, dtype=np.float64), pos_dm.shape[0]))

delta *= Masses[1]
# now check that the total mass in the density field is equal to the total mass in the
# simulation
print('%.3e should be equal to\n%.3e'%(np.sum(delta, dtype=np.float64),
                                       pos_dm.shape[0]*Masses[1]))


# box is 1000Mpc/hand each voxel is ~2Mpc/h (for grid of 512).  So if we take 5 slices we can consider
# a region that has ~10Mpc/h in width.


size = BoxSize / grid
print(f"Each voxel is {size}Mpc/h")
while True:
    Slice = int(input("No. of slices per voxel: "))
    
    if isinstance(Slice, int):
        break
    else:
        print("Invalid input, please enter an integer")

mean_density = np.mean(delta[:Slice,:,:],axis=0) #Take the first 5 component along the first
# axis and compute the mean value
print('Image shape:',mean_density.shape)
print('%.3e < mass < %.3e'%(np.min(mean_density), np.max(mean_density)))

# now lets consider the particles in that slide
indexes = np.where((pos_dm[:,0]<10))
pos_slide = pos_dm[indexes]
print('%.3f < X < %.3f'%(np.min(pos_slide[:,0]), np.max(pos_slide[:,0])))
print('%.3f < Y < %.3f'%(np.min(pos_slide[:,1]), np.max(pos_slide[:,1])))
print('%.3f < Z < %.3f'%(np.min(pos_slide[:,2]), np.max(pos_slide[:,2])))


#################################Draw Density Fields#####################################


import matplotlib.pyplot as plt
from mpl_toolkits.axes_grid1 import make_axes_locatable
from scipy.stats import *
from pylab import *

def draw_density_field1(ax):
    # Creates a gridded 2D slice of the mass-assigned density field

    divider = make_axes_locatable(ax)
    
    ax_cb = divider.append_axes("right", size="5%", pad=0.05)
    fig = ax.get_figure()
    fig.add_axes(ax_cb)
    
    im = ax.imshow(mean_density.T, cmap='gnuplot', vmin=0.0, vmax=1e13, origin='lower')
    
    plt.colorbar(im, cax=ax_cb)
    ax_cb.yaxis.tick_right()
    ax_cb.yaxis.set_tick_params(labelright=False)
    
def draw_density_field2(ax):
    # Create a scatter plot of every particles position
    divider = make_axes_locatable(ax)
    
    ax_cb = divider.append_axes("right", size="5%", pad=0.05)
    fig = ax.get_figure()
    fig.add_axes(ax_cb)

    #Bin data to produce a colour density, loses some resolution however increasing the gridsize
    #makes the image blank
    ax.hexbin(pos_slide[:,1], pos_slide[:,2], gridsize=50, cmap='viridis')
    plt.colorbar(ax.collections[0], cax=ax_cb)

    #####################################################

    # This method has a runtime that is too long for my laptop to process,
    # however I think it is likely better/more detailed than the one used above

    #values = np.vstack([pos_slide[:,1], pos_slide[:,2]])
    #density_values = gaussian_kde(values)(values)
    #kde = kernel.evaluate(kernel)
    #im = ax.scatter(pos_slide[:,1], pos_slide[:,2], s=0.001, c=density_values,
    #                cmap='viridis')
    #plt.colorbar(im, cax=ax_cb)
    #ax_cb.yaxis.tick_right()
    #ax_cb.yaxis.set_tick_params(labelright=False)
    ####################################################
    
def draw_density_fields():
    fig = figure(figsize=(20,10))
    
    ax1 = fig.add_subplot(121)
    draw_density_field1(ax1)
    ax2 = fig.add_subplot(122)
    draw_density_field2(ax2)
    
    
    ax2.set_aspect('equal')
    ax1.set_xlabel('Mpc/h')
    ax1.set_ylabel('Mpc/h')
    ax1.set_title(f"Desnity field of {Title}")
    ax2.set_xlabel('Mpc/h')
    ax2.set_ylabel('Mpc/h')
    ax2.set_title(f"Density field of {Title}")
    
    plt.show()

draw_density_fields()

# at this point, delta contains the effective number of particles in each voxel
# now compute overdensity and density contrast
delta /= np.mean(delta, dtype=np.float64);  delta -= 1.0

print('%.3f < delta < %.3f'%(np.min(delta), np.max(delta)))
print('<delta> = %.3f'%np.mean(delta))
print('shape of the matrix:', delta.shape)
print('density field data type:', delta.dtype)
